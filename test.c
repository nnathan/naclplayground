#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "tweetnacl.h"
#define FOR(i,n) for (i = 0;i < n;++i)
#define sv static void
typedef unsigned char u8;
typedef unsigned long long u64;

void randombytes(u8 *x,u64 xlen) {
  static int fd = -1;
  int i;

  if (fd == -1) {
    for (;;) {
      fd = open("/dev/urandom",O_RDONLY);
      if (fd != -1) break;
      sleep(1);
    }
  }

  while (xlen > 0) {
    if (xlen < 1048576) i = xlen; else i = 1048576;

    i = read(fd,x,i);
    if (i < 1) {
      sleep(1);
      continue;
    }

    x += i;
    xlen -= i;
  }
}

#include <stdio.h>
#include <assert.h>


/* RFC7748 section 5.2 */
sv test_rfc7748_1(void) {
  u8 r[2][crypto_scalarmult_BYTES];

  const u8
    s[2][crypto_scalarmult_SCALARBYTES] = {
      {0xa5,0x46,0xe3,0x6b,0xf0,0x52,0x7c,0x9d,0x3b,0x16,0x15,0x4b,0x82,0x46,0x5e,0xdd,0x62,0x14,0x4c,0x0a,0xc1,0xfc,0x5a,0x18,0x50,0x6a,0x22,0x44,0xba,0x44,0x9a,0xc4},
      {0x4b,0x66,0xe9,0xd4,0xd1,0xb4,0x67,0x3c,0x5a,0xd2,0x26,0x91,0x95,0x7d,0x6a,0xf5,0xc1,0x1b,0x64,0x21,0xe0,0xea,0x01,0xd4,0x2c,0xa4,0x16,0x9e,0x79,0x18,0xba,0x0d}
    },
    u[2][crypto_scalarmult_BYTES] = {
      {0xe6,0xdb,0x68,0x67,0x58,0x30,0x30,0xdb,0x35,0x94,0xc1,0xa4,0x24,0xb1,0x5f,0x7c,0x72,0x66,0x24,0xec,0x26,0xb3,0x35,0x3b,0x10,0xa9,0x03,0xa6,0xd0,0xab,0x1c,0x4c},
      {0xe5,0x21,0x0f,0x12,0x78,0x68,0x11,0xd3,0xf4,0xb7,0x95,0x9d,0x05,0x38,0xae,0x2c,0x31,0xdb,0xe7,0x10,0x6f,0xc0,0x3c,0x3e,0xfc,0x4c,0xd5,0x49,0xc7,0x15,0xa4,0x93}
    },
    e[2][crypto_scalarmult_SCALARBYTES] = {
      {0xc3,0xda,0x55,0x37,0x9d,0xe9,0xc6,0x90,0x8e,0x94,0xea,0x4d,0xf2,0x8d,0x08,0x4f,0x32,0xec,0xcf,0x03,0x49,0x1c,0x71,0xf7,0x54,0xb4,0x07,0x55,0x77,0xa2,0x85,0x52},
      {0x95,0xcb,0xde,0x94,0x76,0xe8,0x90,0x7d,0x7a,0xad,0xe4,0x5c,0xb4,0xb8,0x73,0xf8,0x8b,0x59,0x5a,0x68,0x79,0x9f,0xa1,0x52,0xe6,0xf8,0xf7,0x64,0x7a,0xac,0x79,0x57}
    };

  assert(0 == crypto_scalarmult(r[0],s[0],u[0]));
  assert(0 == crypto_verify_32(r[0],e[0]));
  assert(0 == crypto_scalarmult(r[1],s[1],u[1]));
  assert(0 == crypto_verify_32(r[1],e[1]));
}

/* RFC7748 section 5.2 */
sv test_rfc7748_2(void) {
  int i;

  const u8
    _1[crypto_scalarmult_SCALARBYTES] = {0x42,0x2c,0x8e,0x7a,0x62,0x27,0xd7,0xbc,0xa1,0x35,0x0b,0x3e,0x2b,0xb7,0x27,0x9f,0x78,0x97,0xb8,0x7b,0xb6,0x85,0x4b,0x78,0x3c,0x60,0xe8,0x03,0x11,0xae,0x30,0x79},
    _1000[crypto_scalarmult_SCALARBYTES] = {0x68,0x4c,0xf5,0x9b,0xa8,0x33,0x09,0x55,0x28,0x00,0xef,0x56,0x6f,0x2f,0x4d,0x3c,0x1c,0x38,0x87,0xc4,0x93,0x60,0xe3,0x87,0x5f,0x2e,0xb9,0x4d,0x99,0x53,0x2c,0x51};

  u8
    k[crypto_scalarmult_SCALARBYTES] = {9},
    u[crypto_scalarmult_SCALARBYTES] = {9},
    t[crypto_scalarmult_SCALARBYTES];

  FOR(i,1000) {
    int j;
    if (i==1) assert(0 == crypto_verify_32(k,_1));
    FOR(j,32) t[j] = k[j];
    assert(0 == crypto_scalarmult(k,k,u));
    FOR(j,32) u[j] = t[j];
  }
  assert(0 == crypto_verify_32(k,_1000));
}

/* RFC7748 section 6.1 */
sv test_rfc7748_3(void) {
  const u8
    Ask[crypto_scalarmult_BYTES] = {0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a},
    Bsk[crypto_scalarmult_BYTES] = {0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb},
    eApk[crypto_scalarmult_SCALARBYTES] = {0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a},
    eBpk[crypto_scalarmult_SCALARBYTES] = {0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f},
    ek[crypto_scalarmult_SCALARBYTES] = {0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42};

  u8
    Apk[crypto_scalarmult_SCALARBYTES],
    Bpk[crypto_scalarmult_SCALARBYTES],
    Ak[crypto_scalarmult_SCALARBYTES],
    Bk[crypto_scalarmult_SCALARBYTES];

  assert(0 == crypto_scalarmult_base(Apk,Ask));
  assert(0 == crypto_verify_32(Apk,eApk));
  assert(0 == crypto_scalarmult_base(Bpk,Bsk));
  assert(0 == crypto_verify_32(Bpk,eBpk));
  assert(0 == crypto_scalarmult(Ak,Ask,Bpk));
  assert(0 == crypto_verify_32(Ak,ek));
  assert(0 == crypto_scalarmult(Bk,Bsk,Apk));
  assert(0 == crypto_verify_32(Bk,ek));
}

int main(int argc, char **argv) {
  test_rfc7748_1();
  test_rfc7748_2();
  test_rfc7748_3();
}
