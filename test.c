#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "tweetnacl.h"
#define FOR(i,n) for (i = 0;i < n;++i)
#define sv static void
typedef unsigned char u8;
typedef unsigned long u32;
typedef unsigned long long u64;

void randombytes(u8 *x,u64 xlen) {
  static int fd = -1;
  int i;

  if (fd == -1) {
    for (;;) {
      fd = open("/dev/urandom",O_RDONLY);
      if (fd != -1) break;
      sleep(1);
    }
  }

  while (xlen > 0) {
    if (xlen < 1048576) i = xlen; else i = 1048576;

    i = read(fd,x,i);
    if (i < 1) {
      sleep(1);
      continue;
    }

    x += i;
    xlen -= i;
  }
}

#include <stdio.h>
#include <assert.h>


/* RFC7748 section 5.2 */
sv test_rfc7748_1(void) {
  u8 r[2][crypto_scalarmult_BYTES];

  const u8
    s[2][crypto_scalarmult_SCALARBYTES] = {
      {0xa5,0x46,0xe3,0x6b,0xf0,0x52,0x7c,0x9d,0x3b,0x16,0x15,0x4b,0x82,0x46,0x5e,0xdd,0x62,0x14,0x4c,0x0a,0xc1,0xfc,0x5a,0x18,0x50,0x6a,0x22,0x44,0xba,0x44,0x9a,0xc4},
      {0x4b,0x66,0xe9,0xd4,0xd1,0xb4,0x67,0x3c,0x5a,0xd2,0x26,0x91,0x95,0x7d,0x6a,0xf5,0xc1,0x1b,0x64,0x21,0xe0,0xea,0x01,0xd4,0x2c,0xa4,0x16,0x9e,0x79,0x18,0xba,0x0d}
    },
    u[2][crypto_scalarmult_BYTES] = {
      {0xe6,0xdb,0x68,0x67,0x58,0x30,0x30,0xdb,0x35,0x94,0xc1,0xa4,0x24,0xb1,0x5f,0x7c,0x72,0x66,0x24,0xec,0x26,0xb3,0x35,0x3b,0x10,0xa9,0x03,0xa6,0xd0,0xab,0x1c,0x4c},
      {0xe5,0x21,0x0f,0x12,0x78,0x68,0x11,0xd3,0xf4,0xb7,0x95,0x9d,0x05,0x38,0xae,0x2c,0x31,0xdb,0xe7,0x10,0x6f,0xc0,0x3c,0x3e,0xfc,0x4c,0xd5,0x49,0xc7,0x15,0xa4,0x93}
    },
    e[2][crypto_scalarmult_SCALARBYTES] = {
      {0xc3,0xda,0x55,0x37,0x9d,0xe9,0xc6,0x90,0x8e,0x94,0xea,0x4d,0xf2,0x8d,0x08,0x4f,0x32,0xec,0xcf,0x03,0x49,0x1c,0x71,0xf7,0x54,0xb4,0x07,0x55,0x77,0xa2,0x85,0x52},
      {0x95,0xcb,0xde,0x94,0x76,0xe8,0x90,0x7d,0x7a,0xad,0xe4,0x5c,0xb4,0xb8,0x73,0xf8,0x8b,0x59,0x5a,0x68,0x79,0x9f,0xa1,0x52,0xe6,0xf8,0xf7,0x64,0x7a,0xac,0x79,0x57}
    };

  assert(0 == crypto_scalarmult(r[0],s[0],u[0]));
  assert(0 == crypto_verify_32(r[0],e[0]));
  assert(0 == crypto_scalarmult(r[1],s[1],u[1]));
  assert(0 == crypto_verify_32(r[1],e[1]));
}

/* RFC7748 section 5.2 */
sv test_rfc7748_2(void) {
  int i;

  const u8
    _1[crypto_scalarmult_SCALARBYTES] = {0x42,0x2c,0x8e,0x7a,0x62,0x27,0xd7,0xbc,0xa1,0x35,0x0b,0x3e,0x2b,0xb7,0x27,0x9f,0x78,0x97,0xb8,0x7b,0xb6,0x85,0x4b,0x78,0x3c,0x60,0xe8,0x03,0x11,0xae,0x30,0x79},
    _1000[crypto_scalarmult_SCALARBYTES] = {0x68,0x4c,0xf5,0x9b,0xa8,0x33,0x09,0x55,0x28,0x00,0xef,0x56,0x6f,0x2f,0x4d,0x3c,0x1c,0x38,0x87,0xc4,0x93,0x60,0xe3,0x87,0x5f,0x2e,0xb9,0x4d,0x99,0x53,0x2c,0x51};

  u8
    k[crypto_scalarmult_SCALARBYTES] = {9},
    u[crypto_scalarmult_SCALARBYTES] = {9},
    t[crypto_scalarmult_SCALARBYTES];

  FOR(i,1000) {
    int j;
    if (i==1) assert(0 == crypto_verify_32(k,_1));
    FOR(j,32) t[j] = k[j];
    assert(0 == crypto_scalarmult(k,k,u));
    FOR(j,32) u[j] = t[j];
  }
  assert(0 == crypto_verify_32(k,_1000));
}

/* RFC7748 section 6.1 */
sv test_rfc7748_3(void) {
  const u8
    Ask[crypto_scalarmult_BYTES] = {0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a},
    Bsk[crypto_scalarmult_BYTES] = {0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb},
    eApk[crypto_scalarmult_SCALARBYTES] = {0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a},
    eBpk[crypto_scalarmult_SCALARBYTES] = {0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f},
    ek[crypto_scalarmult_SCALARBYTES] = {0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42};

  u8
    Apk[crypto_scalarmult_SCALARBYTES],
    Bpk[crypto_scalarmult_SCALARBYTES],
    Ak[crypto_scalarmult_SCALARBYTES],
    Bk[crypto_scalarmult_SCALARBYTES];

  assert(0 == crypto_scalarmult_base(Apk,Ask));
  assert(0 == crypto_verify_32(Apk,eApk));
  assert(0 == crypto_scalarmult_base(Bpk,Bsk));
  assert(0 == crypto_verify_32(Bpk,eBpk));
  assert(0 == crypto_scalarmult(Ak,Ask,Bpk));
  assert(0 == crypto_verify_32(Ak,ek));
  assert(0 == crypto_scalarmult(Bk,Bsk,Apk));
  assert(0 == crypto_verify_32(Bk,ek));
}

sv test_chacha20(void) {
  char k[32] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
  char p[113] = "Ladies and Gentlemen of the class of '99: If I could offer you only one tip forthe future, sunscreen would be it.";
  char n[12] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00};
  char out[113] = {0};
  assert(0 == crypto_stream_salsa20_xor(out,p,sizeof(p),n,k));
  int i;
  FOR(i,113) printf("%02x:", p[i]); printf("\n");
}

sv test_chacha20_1(void) {
  unsigned char k[32] = {0};
  unsigned char n[16] = {0};
  unsigned char p[64] = {0};
  unsigned char c[64] = {0};
  int i;
  chacha20_core(c,n,k,"expand 32-byte k",0);
  FOR(i,sizeof(c)) printf("%02x:", c[i]); printf("\n");
}

sv test_chacha20_2(void) {
  int i;
  unsigned char k[32]; FOR(i,32) k[i]=i;
  unsigned char n[16] = "\x01\x00\x00\x00\x00\x00\x00\x09\x00\x00\x00\x4a\x00\x00\x00\x00";
  unsigned char c[64] = {0};
  chacha20_core(c,n,k,"expand 32-byte k",0);
  FOR(i,sizeof(c)) printf("%02x:", c[i]); printf("\n");
}


static u32 L32(u32 x,int c) { return (x << c) | ((x&0xffffffff) >> (32 - c)); }

#define QR(a,b,c,d) {               \
 a += b; d ^= a; d = L32(d, 16);  \
 c += d; b ^= c; b = L32(b, 12);  \
 a += b; d ^= a; d = L32(d, 8);   \
 c += d; b ^= c; b = L32(b, 7); } 

sv test_qr(void) {
  u32  t[4] = {0x11111111,0x01020304,0x9b8d6f43,0x01234567};
  t[0] += t[1]; t[3] ^= t[0]; t[3] = L32(t[3], 16);
  t[2] += t[3]; t[1] ^= t[2]; t[1] = L32(t[1], 12);
  t[0] += t[1]; t[3] ^= t[0]; t[3] = L32(t[3], 8);
  t[2] += t[3]; t[1] ^= t[2]; t[1] = L32(t[1], 7); 
  int i;
  FOR(i,4) printf("%08x\n", t[i]);
}

static u32 ld32(const u8 *x)
{
  u32 u = x[3];
  u = (u<<8)|x[2];
  u = (u<<8)|x[1];
  return (u<<8)|x[0];
}
sv st32(u8 *x,u32 u)
{
  int i;
  FOR(i,4) { x[i] = u; u >>= 8; }
}
sv test_ccb(void) {
  u32 w[16],x[16],y[16],t[4];
  u8 out[64];
  int i,j,m;

  u8 c[16] = "expand 32-byte k";
  u8 k[32]; FOR(i,32) k[i]=i;
  u8 n[16] = "\x01\x00\x00\x00\x00\x00\x00\x09\x00\x00\x00\x4a\x00\x00\x00\x00";

  FOR(i,4) {
    x[i] = ld32(c+4*i);
    x[4+i] = ld32(k+4*i);
    x[8+i] = ld32(k+16+4*i);
    x[12+i] = ld32(n+4*i);
  }

  FOR(i,16) y[i] = x[i];
  printf("state setup\n");
  FOR(m,4) {
    printf("%08x %08x %08x %08x", x[4*m], x[4*m+1], x[4*m+2], x[4*m+3]);
    printf("\n");
  }
  printf("\n");  


  FOR(i,10) {
    QR(x[0],x[4],x[8 ],x[12]);
    QR(x[1],x[5],x[9 ],x[13]);
    QR(x[2],x[6],x[10],x[14]);
    QR(x[3],x[7],x[11],x[15]);
    QR(x[0],x[5],x[10],x[15]);
    QR(x[1],x[6],x[11],x[12]);
    QR(x[2],x[7],x[8 ],x[13]);
    QR(x[3],x[4],x[9 ],x[14]);
  }

  printf("end state\n");
  FOR(m,4) {
    printf("%08x %08x %08x %08x", x[4*m], x[4*m+1], x[4*m+2], x[4*m+3]);
    printf("\n");
  }
  printf("\n");  

  FOR(i,16) st32(out + 4 * i,x[i] + y[i]);

  printf("out block\n");
  FOR(i,16) {
      printf("%02x%02x%02x%02x ", out[4*i], out[4*i+1], out[4*i+2], out[4*i+3]);
  }
}

int main(int argc, char **argv) {
  //test_chacha20_1();
  test_chacha20_2();
  //test_ccb();
  //test_rfc7748_1();
  //test_rfc7748_2();
  //test_rfc7748_3();
}
